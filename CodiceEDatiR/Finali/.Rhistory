source("C:/Users/utente/Desktop/BenfBeng/SAS/TestR/Last/ModelloPersonalizzato.R", echo = TRUE)
source("C:/Users/utente/Desktop/BenfBeng/SAS/TestR/Last/ProgettoAggiornato.R", echo = TRUE)
source("C:/Users/utente/Desktop/BenfBeng/SAS/TestR/Last/ProgettoRecente.R", echo = TRUE)
source("C:/Users/utente/Desktop/BenfBeng/SAS/TestR/Last/ProgettoRecente.R", echo = TRUE)
source("C:/Users/utente/Desktop/BenfBeng/SAS/TestR/Last/RobustForecasting_Production.R", echo = TRUE)
source("C:/Users/utente/Desktop/BenfBeng/SAS/TestR/Last/HybridModel_Advanced_Forecast.R", echo = TRUE)
source("C:/Users/utente/Desktop/BenfBeng/SAS/TestR/Last/ARIMA_AutoSelection_7M.R", echo = TRUE)
source("C:/Users/utente/Desktop/BenfBeng/SAS/TestR/Finali/HybridMachineLearning.R", echo = TRUE)
source("C:/Users/utente/Desktop/BenfBeng/SAS/TestR/Finali/HybridMachineLearning.R", echo = TRUE)
source("C:/Users/utente/Desktop/BenfBeng/SAS/TestR/Finali/HybridMachineLearning.R", echo = TRUE)
source("C:/Users/utente/Desktop/BenfBeng/SAS/TestR/Finali/HybridMachineLearning.R", echo = TRUE)
source("C:/Users/utente/Desktop/BenfBeng/SAS/TestR/Finali/HybridMachineLearning.R", echo = TRUE)
load("C:/Users/utente/Desktop/BenfBeng/SAS/TestR/Finali/.RData")
source("C:/Users/utente/Desktop/BenfBeng/SAS/TestR/Finali/HybridModel_Advanced_Forecast.R", echo = TRUE)
source("C:/Users/utente/Desktop/BenfBeng/SAS/TestR/Finali/HybridModel_Advanced_Forecast.R", echo = TRUE)
source("C:/Users/utente/Desktop/BenfBeng/SAS/TestR/Finali/HybridModel_Advanced_Forecast.R", echo = TRUE)
source("C:/Users/utente/Desktop/BenfBeng/SAS/TestR/Finali/HybridModel_Advanced_Forecast.R", echo = TRUE)
source("C:/Users/utente/Desktop/BenfBeng/SAS/TestR/Finali/HybridModel_Advanced_Forecast.R", echo = TRUE)
source("C:/Users/utente/Desktop/BenfBeng/SAS/TestR/Finali/HybridModel_Advanced_Forecast.R", echo = TRUE)
source("C:/Users/utente/Desktop/BenfBeng/SAS/TestR/Finali/HybridModel_Advanced_Forecast.R", echo = TRUE)
source("C:/Users/utente/Desktop/BenfBeng/SAS/TestR/Finali/HybridModel_Advanced_Forecast.R", echo = TRUE)
source("C:/Users/utente/Desktop/BenfBeng/SAS/TestR/Finali/HybridModel_Advanced_Forecast.R", echo = TRUE)
source("C:/Users/utente/Desktop/BenfBeng/SAS/TestR/Finali/HybridModel_Advanced_Forecast.R", echo = TRUE)
source("C:/Users/utente/Desktop/BenfBeng/SAS/TestR/Finali/HybridModel_Advanced_Forecast.R", echo = TRUE)
1
2
source("C:/Users/utente/Desktop/BenfBeng/SAS/TestR/Finali/HybridModel_Advanced_Forecast.R", echo = TRUE)
source("C:/Users/utente/Desktop/BenfBeng/SAS/TestR/Finali/HybridModel_Advanced_Forecast.R", echo = TRUE)
source("C:/Users/utente/Desktop/BenfBeng/SAS/TestR/Finali/HybridModel_Advanced_Forecast.R", echo = TRUE)
source("C:/Users/utente/Desktop/BenfBeng/SAS/TestR/Finali/HybridModel_Advanced_Forecast.R", echo = TRUE)
source("C:/Users/utente/Desktop/BenfBeng/SAS/TestR/Finali/HybridModel_Advanced_Forecast.R", echo = TRUE)
source("C:/Users/utente/Desktop/BenfBeng/SAS/TestR/Finali/HybridModel_Advanced_Forecast.R", echo = TRUE)
source("C:/Users/utente/Desktop/BenfBeng/SAS/TestR/Finali/HybridModel_Advanced_Forecast.R", echo = TRUE)
source("C:/Users/utente/Desktop/BenfBeng/SAS/TestR/Finali/HybridModel_Advanced_Forecast.R", echo = TRUE)
source("C:/Users/utente/Desktop/BenfBeng/SAS/TestR/Finali/HybridModel_Advanced_Forecast.R", echo = TRUE)
library(readxl)
library(fpp3)
library(dplyr)
library(lubridate)
library(janitor)
library(ggplot2)
library(forecast)
library(purrr)
library(modelr)
# Funzione per calcolare media mobile ponderata
weighted_moving_average <- function(x, weights = c(0.5, 0.3, 0.2)) {
n <- length(x)
if(n < length(weights)) return(rep(mean(x, na.rm = TRUE), n))
result <- numeric(n)
for(i in seq_along(weights)) {
result[1:(length(weights)-1)] <- mean(x[1:length(weights)], na.rm = TRUE)
}
for(i in length(weights):n) {
if(i == length(weights)) {
result[i] <- sum(x[(i-length(weights)+1):i] * rev(weights), na.rm = TRUE)
} else {
result[i] <- sum(x[(i-length(weights)+1):i] * rev(weights), na.rm = TRUE)
}
}
return(result)
}
# Funzione per rilevare trend breaks
detect_trend_breaks <- function(ts_data, min_size = 6) {
if(nrow(ts_data) < min_size * 2) return(NULL)
values <- ts_data$qta_prodotta_tot
n <- length(values)
# Calcola differenze di trend in finestre mobili
breaks <- c()
for(i in seq(min_size, n - min_size)) {
before <- lm(values[max(1, i-min_size):i] ~ I(max(1, i-min_size):i))$coefficients[2]
after <- lm(values[i:(i+min_size)] ~ I(i:(i+min_size)))$coefficients[2]
if(!is.na(before) && !is.na(after) && abs(before - after) > sd(diff(values), na.rm = TRUE)) {
breaks <- c(breaks, i)
}
}
return(unique(breaks))
}
# Componente stagionale adattiva
adaptive_seasonal <- function(ts_data, period = 12) {
if(nrow(ts_data) < period * 2) return(rep(0, nrow(ts_data)))
values <- ts_data$qta_prodotta_tot
seasonal_component <- numeric(length(values))
# Calcola stagionalit√† usando decomposizione robusta
if(length(values) >= period * 2) {
ts_obj <- ts(values, frequency = period)
decomp <- tryCatch({
stl(ts_obj, s.window = "periodic", robust = TRUE)
}, error = function(e) {
# Fallback: stagionalit√† semplice
seasonal_means <- tapply(values, rep(1:period, length.out = length(values)), mean, na.rm = TRUE)
list(time.series = cbind(seasonal = rep(seasonal_means, length.out = length(values))))
})
if(is.list(decomp) && "time.series" %in% names(decomp)) {
seasonal_component <- as.numeric(decomp$time.series[, "seasonal"])
} else {
seasonal_component <- rep(0, length(values))
}
}
return(seasonal_component)
}
# Modello principale personalizzato
custom_forecasting_model <- function(train_data, h = 6) {
cat("üîß Inizializzazione modello personalizzato...\n")
# 1. ANALISI COMPONENTI
# ===============================================================
# Trend con breakpoints
trend_breaks <- detect_trend_breaks(train_data)
cat("üìà Breakpoints rilevati:", length(trend_breaks), "\n")
# Componente stagionale adattiva
seasonal_comp <- adaptive_seasonal(train_data)
cat("üìÖ Componente stagionale calcolata\n")
# 2. MODELLAZIONE DELLE COMMESSE
# ===============================================================
# Relazione quantit√†-commesse con regressione robusta
if("n_commesse" %in% names(train_data)) {
# Modello robusto per relazione qta ~ n_commesse
lm_commesse <- lm(qta_prodotta_tot ~ n_commesse + I(n_commesse^2),
data = train_data)
# Coefficiente di determinazione
r_squared_commesse <- summary(lm_commesse)$r.squared
cat("üìä R¬≤ relazione qta-commesse:", round(r_squared_commesse, 3), "\n")
# Residui dalla relazione commesse
residui_commesse <- residuals(lm_commesse)
} else {
lm_commesse <- NULL
residui_commesse <- train_data$qta_prodotta_tot
r_squared_commesse <- 0
}
# 3. MODELLAZIONE RESIDUI CON ARIMA
# ===============================================================
# Rimuovi trend deterministico e stagionalit√†
detrended <- residui_commesse - seasonal_comp
# ARIMA sui residui
arima_residui <- tryCatch({
auto.arima(detrended, seasonal = FALSE, stepwise = FALSE, approximation = FALSE)
}, error = function(e) {
arima(detrended, order = c(1,1,1))
})
cat("üéØ ARIMA sui residui:", paste(arima_residui$arma[c(1,6,2)], collapse = ","), "\n")
# 4. MODELLO ENSEMBLE PESATO
# ===============================================================
# Pesi basati su performance storica
if(nrow(train_data) >= 12) {
# Validazione rolling window
errors <- c()
for(i in 12:(nrow(train_data)-1)) {
train_subset <- train_data[1:i, ]
actual <- train_data$qta_prodotta_tot[i+1]
# Previsione semplice
pred_naive <- train_subset$qta_prodotta_tot[nrow(train_subset)]
pred_trend <- mean(tail(train_subset$qta_prodotta_tot, 3), na.rm = TRUE)
error_naive <- abs(actual - pred_naive)
error_trend <- abs(actual - pred_trend)
errors <- c(errors, min(error_naive, error_trend))
}
performance_metric <- 1 / (1 + mean(errors, na.rm = TRUE))
} else {
performance_metric <- 0.5
}
# 5. COSTRUZIONE OGGETTO MODELLO
# ===============================================================
model_obj <- list(
# Componenti del modello
trend_breaks = trend_breaks,
seasonal_component = seasonal_comp,
lm_commesse = lm_commesse,
arima_residui = arima_residui,
# Dati di training
train_data = train_data,
performance_metric = performance_metric,
# Parametri
n_obs = nrow(train_data),
has_commesse = "n_commesse" %in% names(train_data),
r_squared_commesse = r_squared_commesse,
# Metadata
fitted_date = Sys.Date(),
model_type = "custom_hybrid"
)
class(model_obj) <- "custom_forecasting_model"
cat("‚úÖ Modello personalizzato creato con successo!\n")
return(model_obj)
}
# Funzione di previsione per il modello personalizzato
forecast.custom_forecasting_model <- function(model, h = 6, future_data = NULL) {
cat("üîÆ Generazione previsioni personalizzate per", h, "periodi...\n")
train_data <- model$train_data
last_date <- max(train_data$data_mese, na.rm = TRUE)
# Date future
future_dates <- seq.Date(from = as.Date(last_date) + months(1),
by = "month", length.out = h)
# 1. STIMA N_COMMESSE FUTURE
# ===============================================================
if(model$has_commesse && is.null(future_data)) {
# Stima n_commesse come media stagionale
mesi_storici <- month(train_data$data_mese)
mesi_futuri <- month(future_dates)
n_commesse_future <- numeric(h)
for(i in seq_along(mesi_futuri)) {
mese_target <- mesi_futuri[i]
commesse_stesso_mese <- train_data$n_commesse[mesi_storici == mese_target]
if(length(commesse_stesso_mese) > 0) {
# Media ponderata: pi√π peso ai dati recenti
weights <- exp(seq(-2, 0, length.out = length(commesse_stesso_mese)))
n_commesse_future[i] <- weighted.mean(commesse_stesso_mese, weights, na.rm = TRUE)
} else {
n_commesse_future[i] <- mean(train_data$n_commesse, na.rm = TRUE)
}
}
} else if(!is.null(future_data) && "n_commesse" %in% names(future_data)) {
n_commesse_future <- future_data$n_commesse[1:h]
} else {
n_commesse_future <- rep(mean(train_data$n_commesse, na.rm = TRUE), h)
}
# 2. PREVISIONE COMPONENTE COMMESSE
# ===============================================================
if(!is.null(model$lm_commesse)) {
pred_df <- data.frame(n_commesse = n_commesse_future)
pred_commesse <- predict(model$lm_commesse, pred_df)
} else {
pred_commesse <- rep(mean(train_data$qta_prodotta_tot, na.rm = TRUE), h)
}
# 3. PREVISIONE COMPONENTE STAGIONALE
# ===============================================================
seasonal_pattern <- model$seasonal_component
if(length(seasonal_pattern) >= 12) {
# Estrapola pattern stagionale
mesi_futuri <- month(future_dates)
seasonal_future <- numeric(h)
for(i in seq_along(mesi_futuri)) {
mese_target <- mesi_futuri[i]
indices_stesso_mese <- which(month(train_data$data_mese) == mese_target)
if(length(indices_stesso_mese) > 0) {
seasonal_future[i] <- mean(seasonal_pattern[indices_stesso_mese], na.rm = TRUE)
} else {
seasonal_future[i] <- 0
}
}
} else {
seasonal_future <- rep(0, h)
}
# 4. PREVISIONE RESIDUI ARIMA
# ===============================================================
residui_forecast <- forecast(model$arima_residui, h = h)
pred_residui <- as.numeric(residui_forecast$mean)
# 5. COMBINAZIONE FINALE
# ===============================================================
# Previsione base
pred_base <- pred_commesse + seasonal_future + pred_residui
# Aggiustamento per trend recente
trend_recente <- mean(diff(tail(train_data$qta_prodotta_tot, 6)), na.rm = TRUE)
if(!is.na(trend_recente) && abs(trend_recente) > 0) {
trend_adjustment <- trend_recente * seq(1, h) * 0.5  # Damping del trend
pred_base <- pred_base + trend_adjustment
}
# Vincoli realistici
min_val <- min(train_data$qta_prodotta_tot, na.rm = TRUE) * 0.3
max_val <- max(train_data$qta_prodotta_tot, na.rm = TRUE) * 1.5
pred_final <- pmax(min_val, pmin(max_val, pred_base))
# 6. INTERVALLI DI CONFIDENZA
# ===============================================================
# Calcola volatilit√† storica
historical_errors <- diff(train_data$qta_prodotta_tot)
volatility <- sd(historical_errors, na.rm = TRUE) * sqrt(1:h)  # Crescente con h
# Intervalli al 80% e 95%
lower_80 <- pred_final - 1.28 * volatility
upper_80 <- pred_final + 1.28 * volatility
lower_95 <- pred_final - 1.96 * volatility
upper_95 <- pred_final + 1.96 * volatility
# 7. COSTRUZIONE RISULTATO
# ===============================================================
result <- tibble(
data_mese = future_dates,
year_month = yearmonth(future_dates),
.mean = pred_final,
n_commesse_stimate = n_commesse_future,
# Componenti della previsione
componente_commesse = pred_commesse,
componente_stagionale = seasonal_future,
componente_residui = pred_residui,
# Intervalli di confidenza
.lower_80 = pmax(0, lower_80),
.upper_80 = upper_80,
.lower_95 = pmax(0, lower_95),
.upper_95 = upper_95,
# Metadata
.model = "custom_hybrid"
)
cat("‚úÖ Previsioni generate con successo!\n")
cat("üìä Range previsioni:", round(min(result$.mean)), "-", round(max(result$.mean)), "\n")
return(result)
}
-----------------------------------------------------------------------------
# FUNZIONI PER L'ACCURATEZZA
-----------------------------------------------------------------------------
# Funzione per calcolare metriche robuste
calculate_robust_metrics <- function(actual, predicted, training_data = NULL) {
n <- length(actual)
# Metriche base
mae_val <- mean(abs(actual - predicted))
rmse_val <- sqrt(mean((actual - predicted)^2))
# sMAPE (Symmetric Mean Absolute Percentage Error) - pi√π robusto del MAPE
smape_val <- mean(200 * abs(actual - predicted) / (abs(actual) + abs(predicted)))
# NRMSE (Normalized Root Mean Square Error) - basato su varianza
nrmse_val <- rmse_val / mean(actual) * 100
# MASE (Mean Absolute Scaled Error) - scale-independent
if(!is.null(training_data) && length(training_data) > 1) {
naive_mae <- mean(abs(diff(training_data)), na.rm = TRUE)
mase_val <- mae_val / naive_mae
} else {
mase_val <- NA
}
# Mantieni MAPE per compatibilit√†, ma con gestione errori
mape_val <- tryCatch({
# Evita divisione per zero
valid_idx <- abs(actual) > 1e-6
if(sum(valid_idx) > 0) {
mean(abs((actual[valid_idx] - predicted[valid_idx]) / actual[valid_idx])) * 100
} else {
NA
}
}, error = function(e) NA)
return(list(
mae = mae_val,
rmse = rmse_val,
mape = mape_val,
smape = smape_val,
nrmse = nrmse_val,
mase = mase_val,
n_observations = n
))
}
# Valutazione singola previsione
evaluate_single_prediction <- function(actual, predicted, actual_mean = NULL) {
# Errore assoluto
abs_error <- abs(actual - predicted)
# Errore percentuale (gestito per evitare divisione per zero)
perc_error <- if(abs(actual) > 1e-6) {
(predicted - actual) / actual * 100
} else {
NA
}
# Errore percentuale simmetrico (sMAPE per singola osservazione)
smape_single <- if(abs(actual) + abs(predicted) > 1e-6) {
200 * abs_error / (abs(actual) + abs(predicted))
} else {
0
}
# Errore normalizzato rispetto alla media (se disponibile)
normalized_error <- if(!is.null(actual_mean) && actual_mean > 0) {
abs_error / actual_mean * 100
} else {
NA
}
# Score composito per singola previsione (0-1, dove 1 = perfetto)
smape_score <- pmax(0, pmin(1, (50 - smape_single) / 50))
# Classificazione qualitativa basata su score composito
if(smape_score >= 0.90) {  # sMAPE <= 5%
quality <- list(emoji = "üü¢", level = "Eccellente", description = "sMAPE ‚â§ 5%")
} else if(smape_score >= 0.75) {  # sMAPE <= 12.5%
quality <- list(emoji = "üü°", level = "Buona", description = "sMAPE ‚â§ 12.5%")
} else if(smape_score >= 0.50) {  # sMAPE <= 25%
quality <- list(emoji = "üü†", level = "Media", description = "sMAPE ‚â§ 25%")
} else if(smape_score >= 0.25) {  # sMAPE <= 37.5%
quality <- list(emoji = "üî¥", level = "Bassa", description = "sMAPE ‚â§ 37.5%")
} else {  # sMAPE > 37.5%
quality <- list(emoji = "‚ö´", level = "Molto Bassa", description = "sMAPE > 37.5%")
}
return(list(
abs_error = abs_error,
perc_error = perc_error,
smape_single = smape_single,
normalized_error = normalized_error,
score = smape_score,
quality = quality
))
}
source("C:/Users/utente/Desktop/BenfBeng/SAS/TestR/Finali/HybridModel_Advanced_Forecast.R", echo = TRUE)
source("C:/Users/utente/Desktop/BenfBeng/SAS/TestR/Finali/HybridModel_Advanced_Forecast.R", echo = TRUE)
source("C:/Users/utente/Desktop/BenfBeng/SAS/TestR/Finali/HybridModel_Advanced_Forecast.R", echo = TRUE)
source("C:/Users/utente/Desktop/BenfBeng/SAS/TestR/Finali/HybridModel_Advanced_Forecast.R", echo = TRUE)
source("C:/Users/utente/Desktop/BenfBeng/SAS/TestR/Finali/HybridModel_Advanced_Forecast.R", echo = TRUE)
source("C:/Users/utente/Desktop/BenfBeng/SAS/TestR/Finali/HybridModel_Advanced_Forecast.R", echo = TRUE)
source("C:/Users/utente/Desktop/BenfBeng/SAS/TestR/Finali/HybridModel_Advanced_Forecast.R", echo = TRUE)
